FRESHWORKS ROUND 1

Find the k closest points to origin
Time complexity
Optimized approch priority queue
real world kafka use case in company
how do yoi deploy code


INFORMATICA ROUND 1

dIFFERENCE BETWEEN HASHMAP AND HASHSET
WHAT IS HASHSET
WHAT IS DIFFERNCE BETWEEN HASHMAP AND HASHTABLE

HASHMAP HAS MANY CONSTRUCTORS SO WHAT IS LOAD FACTOR 0.75
WHAT US LOAD FACTOR
WHAT IS FAIL SAFE AND FAIL SAFE ITERATOR
WHAT IS CLASS LOADER AND DIFFERENT TYPES OF CLASS LOADER
WHAT IS FINAL FINALLY AND FINALIZE
IS FINALLY BLOCK ALWAYS REQUIRED
WHAT IS CHECKED AND UNCHECKED EXCEPTION AND GIVE EXAMPLES
WHAT IS ROOT CLASS OF EXCEPTION
WHAT IS COLLISION IN HASN MAP AND EXPLAIN IT
WHAT IS STRING IMMUTABLE AND WHAT HAPPENS INSIDE
WHAT IS STRING BUFFER AND STRING BUILDER
REGARDING SYNCHRONISATION ALSO

ALSO IS HASHMAP SYNCHRONIZED
IF HASHMAP CAN BE DONE COLLECTION.SYNCHRONIZED(MP)
THEN WHY CONCURRENT HASHMAP
WHAT IS CONCURRENT HASHMAP
EXPLAIN

WHAT IS FILE NOT FOUND EXCEPTION (RUN TIME OR COMPILE TIME)
WHEN IN TRY BLOCK WE HAVE SYSTEM.EXIT() THEN WILL CATCH AND FINALLY BLOCK...EXECUTE
WHICH IS SYNCHRONISED..THREAD OR THREAD BUFFER
WHAT IS INTERFACE AND ABSTRACT CLASS (DIFFERNEE BETWEEN THEM)

HOW IS OBJECT GARBAGE COLLECTED IN JAVA


GIVEN A STRING S=aaabbbccddddd
O/P= a3b3c2d5
encrypt

Given a string a3b2c1d2
0/P= aaabbcdd
decrypt


INFORMATICA ROUND 2
Find the next smaller element of each element in array

[[4, 8, 5, 2, 25}
[2,2,2,-1]

brute force and stack based approach and scan from right side..


why do we use kafka to communicate between services
any other way to communicate
why we use messaging system

what is garbage collection in java.how its done


FRESHWORKS ROUND 2
Find the longest palindromic substring.
brute force,recusrsion,corner case,tabular and odd length,even length

db design of project
what if parts do not come from other service./




import java.util.Arrays;
import java.util.Stack;

class Main
{
	// Find the next smaller element for every array element
	public static int[] findNextGreaterElements(int[] input)
	{
		// base case
		if (input == null) {
			return input;
		}

		int[] result = new int[input.length];
		Arrays.fill(result, -1);

		// create an empty stack
		Stack<Integer> s = new Stack<>();

		// do for each element
		for (int i = 0; i < input.length; i++)
		{
			// loop till we have a smaller element on top or stack becomes empty.

			// Keep popping elements from the stack larger than the current
			// element, and set their next smaller element to the current element

			while (!s.isEmpty() && input[s.peek()] > input[i]) {
				result[s.pop()] = input[i];
			}

			// push current "index" into the stack
			s.push(i);
		}

		return result;
	}

	public static void main(String[] args)
	{
		int[] input = { 2, 7, 3, 5, 4, 6, 8 };

		int[] result = findNextGreaterElements(input);
		System.out.println(Arrays.toString(result));
	}
}



NEXT GREATER ELEMENT FOR EVERY ARRAY ELEMENY

while (!s.isEmpty() && input[s.peek()] < input[i]) {
				result[s.pop()] = input[i];
			}


FRESHWORKS ROUND 3
FIND ALL PAIRS HAVING GIVEN SUM IN ARRAY

I GAVE SOLN FOR ALL ELEMENTS HAVING GIVEN SUM EQUAL TO K IN ARRAY

HE SAID OK

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Test {

    static void sumArrays(int arr[],int n,int target) {

        int cur_sum = 0;
        HashMap<Integer, List<Integer>> mp = new HashMap<>();
        //for 0 sum,corner case
        if (!mp.containsKey(0)) {
            mp.put(0, new ArrayList<>());
            mp.get(0).add(-1);
        }

        for (int i = 0; i < n; i++) {
            cur_sum += arr[i];
            if (mp.containsKey(cur_sum - target)) {
                List<Integer> vals = mp.get(cur_sum - target);
                for (Integer val : vals) {
                    canprintArray(arr, val + 1, i);
                }

            }
            if (!mp.containsKey(cur_sum)) {
                mp.put(cur_sum, new ArrayList<>());
                mp.get(cur_sum).add(i);
            }

        }
    }
    static void canprintArray(int arr[],int i,int j)
    {
        System.out.println(IntStream.range(i,j+1).mapToObj(l->arr[l]).collect(Collectors.toList()));
    }
    public static void main(String[] args)
    {
        int arr[]={3, 5, -2, 1, 2, 0};
        int n= arr.length;
        int target=3;
        sumArrays(arr,n,target);
    }
}

WHAT IS ADVANTAGE OF DOCKER
WHAT IS LAYERS IN DOCKER
WHY DOCKER AND NOT ZIP FILE
DIFFERENCE BETWEEN GIT MERGE AND GIT REBASE
WHY KAFKA AND NOT RABBIT MQ
WJAT IS KAFKA. AND EXPLAIN KAFKA WHAT IS IT USED FOR


paypal round 1

https://www.techiedelight.com/rearrange-array-positive-negative-numbers-alternate-positions/

partion logic quick sort 0 as pivot element

import java.util.Arrays;
 
class Main
{
    // Partitioning routine of Quicksort
    public static int partition(int[] A)
    {
        int j = 0;
        int pivot = 0;    // consider 0 as a pivot
 
        // each time we find a negative number, `j` is incremented,
        // and a negative element would be placed before the pivot
        for (int i = 0; i < A.length; i++)
        {
            if (A[i] < pivot)
            {
                // swap `A[i]` with `A[j]`
                int temp = A[i];
                A[i] = A[j];
                A[j] = temp;
 
                j++;
            }
        }
 
        // `j` holds the index of the first positive element
        return j;
    }
 
    // Function to rearrange a given array such that it contains positive
    // and negative numbers at alternate positions
    public static void rearrange(int[] A)
    {
        // partition a given array such that all positive elements move
        // to the end of the array
 
        int p = partition(A);
 
        // swap alternate negative elements from the next available positive
        // element till the end of the array is reached, or all negative or
        // positive elements are exhausted.
 
        for (int n = 0; (p < A.length && n < p); p++, n += 2)
        {
            // swap `A[n]` with `A[p]`
            int temp = A[n];
            A[n] = A[p];
            A[p] = temp;
        }
    }
 
    public static void main(String[] args)
    {
        int[] A = { 9, -3, 5, -2, -8, -6, 1, 3 };
 
        rearrange(A);
 
        // print the rearranged array
        System.out.println(Arrays.toString(A));
    }
}
o(n)

for storing relative order need to see
